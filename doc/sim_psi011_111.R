## ---- include = FALSE---------------------------------------------------------
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

## ----echo=TRUE----------------------------------------------------------------
library(ElasticIntegrative)
m <- 2000 # size for RWE
niter <- 2000 # number of replication
thres.psi  <-  sqrt(log(m)) # threshold for ACI psi
alltlocalpar <- c(2,1,round((seq(0.8,0,length.out=8)),2))

## ----eval=FALSE, include=TRUE-------------------------------------------------
#  # psi = c(0, 0, 0)
#  elastic_psi000_lists <- lapply(alltlocalpar, function(tlocalpar)
#    {
#    elastic_list <- sapply(1:niter, function(seed)
#    {
#      Data.list <- GenData(beta0 = c(0, 1, 1, 1), # for the mu0 function
#                           psi0 = c(0, 0, 0), # for the contrast function
#                           n = 1e5, mean.x = 1,  # setup for the finite population
#                           n.t = NULL, # for the RCT, use the default sample size
#                           m = m, tlocalpar = tlocalpar, # for the RWE
#                           seed = seed)
#      elasticHTE(Data.list$RT, # RCT
#                 Data.list$RW, # RWE
#                 thres.psi = thres.psi,
#                 fixed = FALSE # adaptive selection strategy
#                 )
#    })
#    class(elastic_list) <- 'res' # overload
#    elastic_list
#  })
#  # psi = c(0, 1, 1)
#  elastic_psi011_lists <- lapply(alltlocalpar, function(tlocalpar)
#    {
#    elastic_list <- sapply(1:niter, function(seed)
#    {
#      Data.list <- GenData(beta0 = c(0, 1, 1, 1), # for the mu0 function
#                           psi0 = c(0, 1, 1), # for the contrast function
#                           n = 1e5, mean.x = 1,  # setup for the finite population
#                           n.t = NULL, # for the RCT, use the default sample size
#                           m = m, tlocalpar = tlocalpar, # for the RWE
#                           seed = seed)
#      elasticHTE(Data.list$RT, # RCT
#                 Data.list$RW, # RWE
#                 thres.psi = thres.psi,
#                 fixed = FALSE # adaptive selection strategy
#                 )
#    })
#    class(elastic_list) <- 'res'
#    elastic_list
#  })

## ----include=FALSE------------------------------------------------------------
library(dplyr)
library(latex2exp)
library(ggplot2)
library(tidyr)
# the raw data is generated by the Rcode in the data-raw folder
# tabulate the results for psi 000
psi <- c(0, 0, 0)
sim_results_psi00 <-
  sapply(elastic_psi000_lists, function(res)summary(res, psi = psi))
est.mat.psi00 <- do.call(rbind, sim_results_psi00[1,])
ve.mat.psi00 <- do.call(rbind, sim_results_psi00[2,])
CI.width.mat.psi00 <- do.call(rbind, sim_results_psi00[3,])
CP.mat.psi00 <- do.call(rbind, sim_results_psi00[4,])
row.names(est.mat.psi00) <- row.names(ve.mat.psi00) <- 
  row.names(CI.width.mat.psi00) <- row.names(CP.mat.psi00) <- rev(alltlocalpar)
bias.psi0 <- est.mat.psi00-0
variance.psi0 <- ve.mat.psi00

# tabulate the results for psi 011
psi <- c(0, 1, 1)
sim_results_psi11 <-
  sapply(elastic_psi011_lists, function(res)summary(res, psi = psi))
est.mat.psi11 <- do.call(rbind, sim_results_psi11[1,])
ve.mat.psi11 <- do.call(rbind, sim_results_psi11[2,])
CI.width.mat.psi11 <- do.call(rbind, sim_results_psi11[3,])
CP.mat.psi11 <- do.call(rbind, sim_results_psi11[4,])
row.names(est.mat.psi11) <- row.names(ve.mat.psi11) <- 
  row.names(CI.width.mat.psi11) <- row.names(CP.mat.psi11) <- rev(alltlocalpar)
bias.psi1 <- est.mat.psi11-1
variance.psi1 <- ve.mat.psi11

# summary.tables is stored as a part of this package 
CP.mat.psi00 <- CP.mat.psi00[,c('RT.2', 'RT.3',
  'EE.2', 'EE.3',
  'ELAS.2', 'ELAS.3')]
CI.width.mat.psi00 <- CI.width.mat.psi00[,c('RT.2', 'RT.3',
  'EE.2', 'EE.3',
  'ELAS.2', 'ELAS.3')]

CP.mat.psi11 <- CP.mat.psi11[,c('RT.2', 'RT.3',
  'EE.2', 'EE.3',
  'ELAS.2', 'ELAS.3')]
CI.width.mat.psi11 <- CI.width.mat.psi11[,c('RT.2', 'RT.3',
  'EE.2', 'EE.3',
  'ELAS.2', 'ELAS.3')]

## ----echo=FALSE---------------------------------------------------------------
knitr::kable(CP.mat.psi00*100,
             digits = 1,
             caption = 'Simulation results for coverage rates (%) with nonzero effect modification  $\\psi_1=\\psi_2=0$')%>%
  kableExtra::kable_styling(full_width = FALSE, position = "float_left")
knitr::kable(CI.width.mat.psi00*1000,
             digits = 0,
             caption = 'Simulation results for widths of 95% confidence intervals ($\\times 10^{-3}$) with nonzero effect modification  $\\psi_1=\\psi_2=0$')%>%
  kableExtra::kable_styling(full_width = FALSE, position = "left")

## ----echo=FALSE---------------------------------------------------------------
knitr::kable(CP.mat.psi11*100,
             digits = 1,
             caption = 'Simulation results for coverage rates (%) with nonzero effect modification  $\\psi_1=\\psi_2=1$')%>%
  kableExtra::kable_styling(full_width = FALSE, position = "float_left")
knitr::kable(CI.width.mat.psi11*1000,
             digits = 0,
             caption = 'Simulation results for widths of 95% confidence intervals ($\\times 10^{-3}$) with nonzero effect modification  $\\psi_1=\\psi_2=1$')%>%
  kableExtra::kable_styling(full_width = FALSE, position = "left")

## ----echo=FALSE, fig.height=5, fig.width=6.5, fig.align = 'center'------------
# plot the bias, variance and mean squared error
outputs <- list(bias.psi0 = bias.psi0, bias.psi1 = bias.psi1,
                variance.psi0 = variance.psi0, variance.psi1 = variance.psi1)
class(outputs) <- 'res'
plot(x = outputs, AIPW = F)

