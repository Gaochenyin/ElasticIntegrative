---
title: "Simulation example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulation example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(ElasticIntegrative)
```
In this vignette, we will illustrate the use of this package by reproducing the simulation studies in Yang et. al. (2022), Section 4. The following codes layout the simulation setups.
```{r echo=TRUE}
m <- 2000 # size for RWE
niter <- 2000 # number of replication
thres.psi  <-  sqrt(log(m)) # threshold for ECI psi
alltlocalpar <-round((seq(2,0,length.out=10)),2)
```
Now, we generate the necessary datasets by `GenData` and conduct the proposed method by `elasticHTE` for elastic integrative analyses.
```{r eval=FALSE, include=TRUE}
elastic_psi011_lists <- lapply(alltlocalpar, function(tlocalpar)
  {
  elastic_list <- sapply(1:niter, function(seed)
  {
    Data.list <- GenData(beta0 = c(0, 1, 1, 1), # for the mu0 function
                              psi0 = c(0, 1, 1), # for the contrast function
                              om.id = 0, es.id = 0,
                              n = 1e5, mean.x = 1,  # setup for the finite population
                              n.t = NULL, # for the RCT, use the default sample size
                              m = m, tlocalpar = tlocalpar, # for the RWE
                              seed = seed)
    elasticHTE(Data.list$RT, # RCT
               Data.list$RW, # RWE
               fixed = FALSE # adaptive selection strategy
               )
  })
  elastic_list
})
```
At last, we reproduce the summary results in Yang et. al., Table 1 as follow.
```{r include=FALSE}
library(dplyr)
library(kableExtra)
summary_res <- function(res, psi)
{

  # est
  est.mat <- do.call(rbind, lapply(res, function(x)x[[1]][c(paste0('covj.t.',2:3),
                                                            paste0('ee.rt(ml).',2:3),
                                                            paste0('opt.ee(ml).',2:3),
                                                            paste0('elas.',2:3))]))
  colnames(est.mat) <- c(paste0('AIPW.',2:3),
                         paste0('RT.',2:3),
                         paste0('EE.',2:3),
                         paste0('ELAS.',2:3))
  ve.mat <- do.call(rbind, lapply(res, function(x)x[[2]][c(paste0('covj.t.',2:3),
                                                           paste0('ee.rt(ml).',2:3),
                                                           paste0('opt.ee(ml).',2:3))]))
  est <- apply(est.mat, 2, mean)
  est.ve <- apply(est.mat, 2, var)
  
  # CI
  inf.mat <- est.mat[,c(paste0('AIPW.',2:3),
                        paste0('RT.',2:3),
                        paste0('EE.',2:3))]-qnorm(1-0.05/2)*sqrt(ve.mat)
  sup.mat <- est.mat[,c(paste0('AIPW.',2:3),
                        paste0('RT.',2:3),
                        paste0('EE.',2:3))]+qnorm(1-0.05/2)*sqrt(ve.mat)
  
  inf.elas.mat <- est.mat[,paste0('ELAS.', 2:3)]+
    do.call(rbind, lapply(res, function(x)x[[3]][paste0('elas1.',2:3)]))
  sup.elas.mat <- est.mat[,paste0('ELAS.', 2:3)]+
    do.call(rbind, lapply(res, function(x)x[[4]][paste0('elas1.',2:3)]))
  ## width
  CI.width <- c(apply(sup.mat-inf.mat, 2, mean),
                apply(sup.elas.mat-inf.elas.mat, 2, mean))
  ## CP
  # CP.mat.0 <- inf.mat<rep(psi[2:3],3)&
  #   sup.mat>rep(psi[2:3],3)
  
  CP <- c(apply(inf.mat<rep(psi[2:3],3)&
                  sup.mat>rep(psi[2:3],3), 2, mean),
          apply(inf.elas.mat<psi[2:3]&
                  sup.elas.mat>psi[2:3], 2, mean))
  # type I error 
  error <- cbind(inf.mat>0|sup.mat<0,
                 inf.elas.mat>0|sup.elas.mat<0)%>%apply(2, mean)
  # nuisance parameter
  nuisapar.mean <- do.call(rbind, lapply(res, function(x)x$nuispar[c('eta1', 'eta2', 'eta3',
                                                                     'gamma1','c_gamma1',
                                                                     'Icomb1','Icomb2','Icomb3')]))%>%apply(2, mean)
  nuisapar.sd <- do.call(rbind, lapply(res, function(x)x$nuispar[c('eta1', 'eta2', 'eta3',
                                                                   'gamma1','c_gamma1',
                                                                   'Icomb1','Icomb2','Icomb3')]))%>%apply(2, sd)
  # prob.elas <- lapply(res, function(x)
  #   x$nuispar['Tstat.psi']>
  #     x$nuispar['c_gamma1'])%>%unlist()
  prob.elas <- 1-lapply(res, function(x)x$nuispar['conservative'])%>%
    unlist()%>%unname()
  prob.elas.mean <- mean(prob.elas)
  prob.elas.sd <- sd(prob.elas)
  list(est = est,
       ve = est.ve,
       CI.width = CI.width,
       CP = CP,
       error = error,
       nuisapar.mean = nuisapar.mean,
       nuisapar.sd = nuisapar.sd,
       prob.elas.mean = prob.elas.mean,
       prob.elas.sd = prob.elas.sd)
}
# summary.tables is stored as a part of this package 
# the raw data is generated by the Rcode in the data-raw folder
CI.width.table <- do.call(rbind, lapply(summary.tables, function(x)x$CI.width))[, 
                                                              c(
                                                                'RT.2', 'RT.3',
                                                                'EE.2', 'EE.3',
                                                                'ELAS.2', 'ELAS.3'
                                                              )]
CP.width.table <- do.call(rbind, lapply(summary.tables, function(x)x$CP))[, 
                                                              c(
                                                                'RT.2', 'RT.3',
                                                                'EE.2', 'EE.3',
                                                                'ELAS.2', 'ELAS.3'
                                                              )]
row.names(CI.width.table) <- rev(alltlocalpar)
row.names(CP.width.table) <- rev(alltlocalpar)
```
```{r echo=FALSE}
knitr::kable(CP.width.table*100,
             digits = 1,
             caption = 'Simulation results for coverage rates (%) with nonzero effect modification  $\\psi_1=\\psi_2=1$')%>%
  kable_styling(full_width = FALSE, position = "float_left")
knitr::kable(CI.width.table*1000,
             digits = 0,
             caption = 'Simulation results for widths of 95% confidence intervals ($\\times 10^{-3}$) with nonzero effect modification  $\\psi_1=\\psi_2=1$')%>%
  kable_styling(full_width = FALSE, position = "left")
```
